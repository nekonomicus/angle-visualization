function updateVisualization() {
  try {
    // Get all values from controls
    const bPos = parseFloat(document.getElementById('blue-anchor-pos').value);
    const rBaseX = parseFloat(document.getElementById('red-anchor-x').value);
    const rBaseY = parseFloat(document.getElementById('red-anchor-y').value);
    const iAngle = parseFloat(document.getElementById('init-red-angle').value);
    const rot = parseFloat(document.getElementById('rot-angle').value);
    const ovalWidth = parseFloat(document.getElementById('oval-width').value);
    const ovalHeight = parseFloat(document.getElementById('oval-height').value);

    // Update the fixed oval dimensions
    document.querySelector('ellipse:not(#rotating-oval)').setAttribute('rx', ovalWidth);
    document.querySelector('ellipse:not(#rotating-oval)').setAttribute('ry', ovalHeight);
    
    // Update the rotating oval
    // Make it slightly larger
    document.getElementById('rotating-oval').setAttribute('rx', ovalWidth * 1.05);
    document.getElementById('rotating-oval').setAttribute('ry', ovalHeight * 1.05);
    
    // Rotate the entire group (oval + red anchor + red line + rotating spoke)
    document.getElementById('rotating-group').setAttribute('transform', `rotate(${rot})`);

    // Calculate position of blue anchor based on bPos (0 to 1)
    // bPos = 1 means it's at the right edge of the oval
    const bX = ovalWidth * bPos;
    const bY = 0; // Y-coordinate is always 0 for blue anchor
    
    // Update the position of red anchor and line within the rotating group
    // These are fixed relative to the rotating oval
    document.getElementById('rotating-center').setAttribute('cx', rBaseX);
    document.getElementById('rotating-center').setAttribute('cy', rBaseY);
    
    // Update red line, starting from the red anchor
    document.getElementById('red-line').setAttribute('x1', rBaseX);
    document.getElementById('red-line').setAttribute('y1', rBaseY);
    
    // Calculate the end point of the red line using the initial angle
    const redLineRad = iAngle * Math.PI / 180;
    const redLineLength = 4; // Same length as blue line for consistency
    const redLineEndX = rBaseX + redLineLength * Math.cos(redLineRad);
    const redLineEndY = rBaseY - redLineLength * Math.sin(redLineRad); // Subtract because SVG Y is inverted
    
    document.getElementById('red-line').setAttribute('x2', redLineEndX);
    document.getElementById('red-line').setAttribute('y2', redLineEndY);
    
    // Position the red angle handle
    const handleOffset = 0.2; // Offset from the end for arrow
    const redHandleX = rBaseX + (redLineLength - handleOffset) * Math.cos(redLineRad);
    const redHandleY = rBaseY - (redLineLength - handleOffset) * Math.sin(redLineRad);
    document.getElementById('red-angle-handle').setAttribute('cx', redHandleX);
    document.getElementById('red-angle-handle').setAttribute('cy', redHandleY);

    // Update blue anchor and line - MODIFIED to center vertically
    document.getElementById('blue-anchor').setAttribute('cx', bX);
    document.getElementById('blue-anchor').setAttribute('cy', bY);
    
    // Calculate blue line length - using a consistent total length that extends equally up and down
    const blueLineLength = 4; // Total length of blue line
    const blueLineHalfLength = blueLineLength / 2; // Half length for equal extension
    
    // Set the blue line to be centered vertically around the anchor point but reversed direction
    document.getElementById('blue-line').setAttribute('x1', bX);
    document.getElementById('blue-line').setAttribute('y1', bY + blueLineHalfLength); // Start from bottom
    document.getElementById('blue-line').setAttribute('x2', bX);
    document.getElementById('blue-line').setAttribute('y2', bY - blueLineHalfLength); // End at top (arrow here)

    // Update the fixed spoke
    document.getElementById('fixed-spoke').setAttribute('x1', -ovalWidth);
    document.getElementById('fixed-spoke').setAttribute('y1', 0);
    document.getElementById('fixed-spoke').setAttribute('x2', ovalWidth);
    document.getElementById('fixed-spoke').setAttribute('y2', 0);
    
    // Update the rotating spoke
    // Since it's in the rotating group, it's directly horizontal
    const ovalWidthScaled = ovalWidth * 1.05;
    document.getElementById('rotating-spoke').setAttribute('x1', -ovalWidthScaled);
    document.getElementById('rotating-spoke').setAttribute('y1', 0);
    document.getElementById('rotating-spoke').setAttribute('x2', ovalWidthScaled);
    document.getElementById('rotating-spoke').setAttribute('y2', 0);
    
    // Update the rotation handle position
    const rotRad = rot * Math.PI / 180;
    const ovalHeightScaled = ovalHeight * 1.05;
    document.getElementById('rotation-handle').setAttribute('cx', ovalWidthScaled * Math.cos(rotRad));
    document.getElementById('rotation-handle').setAttribute('cy', ovalHeightScaled * Math.sin(rotRad));

    // Calculate the angle between spokes (rotation angle)
    const spokeAngleClock = Math.abs(rot);
    
    // Draw the spoke angle arc at the center - with opposite direction
    const spokeArcPath = describeArc(0, 0, 0.3, 0, rot);
    document.getElementById('spoke-angle-arc').setAttribute('d', spokeArcPath);
    
    // Calculate angles for blue and red lines
    // Blue is pointing down (270° in math angle since we reversed it)
    const blueAngle = 270; // Changed to 270 to reflect downward direction
    // Red line rotates with the oval, so its absolute angle is its initial angle + rotation
    const redAngle = normalizeAngle(iAngle + rot);
    
    // Calculate the angle between blue and red lines
    // This correctly gets the smallest angle between the lines (always ≤ 180°)
    let arrowAngleClock = normalizeAngleToMaxHalf(blueAngle, redAngle);
    
    // Calculate intersection of blue and red lines
    // Blue line is vertical, so x-coordinate is bX
    const intersectionX = bX;
    
    // Calculate the rotated red anchor position
    const rotatedRedX = rBaseX * Math.cos(rotRad) - rBaseY * Math.sin(rotRad);
    const rotatedRedY = rBaseX * Math.sin(rotRad) + rBaseY * Math.cos(rotRad);
    
    // Calculate red line direction after rotation
    const rotatedRedAngleRad = (iAngle + rot) * Math.PI / 180;
    
    // Line equation for rotated red line: y = mx + b
    // m = slope = tan(angle)
    const slope = -Math.tan(rotatedRedAngleRad);
    
    // Calculate b (y-intercept) using rotated red anchor point
    const yIntercept = rotatedRedY - slope * rotatedRedX;
    
    // Find y-coordinate at x = bX
    const intersectionY = slope * bX + yIntercept;
    
    // Determine if intersection is within reasonable viewing range
    const inViewRange = intersectionY >= -10 && intersectionY <= 10;
    
    if (inViewRange) {
      // Draw angle arc and show angle value (using original angle for drawing the arc)
      drawAngleArc(intersectionX, intersectionY, blueAngle, redAngle, arrowAngleClock);
    } else {
      // Hide angle arc and value if intersection is out of view
      document.getElementById('arrow-angle-arc').style.visibility = 'hidden';
      document.getElementById('arrow-angle-value').style.visibility = 'hidden';
    }
    
    // Position the angle value labels near their respective arcs
    // For the spoke angle
    if (spokeAngleClock > 5) {  // Only show if angle is significant
      // Calculate a position halfway along the arc
      const halfAngle = rot / 2;
      const halfAngleRad = halfAngle * Math.PI / 180;
      const spokeAngleLabelRadius = 0.4; // Slightly outside the arc
      const spokeAngleLabelX = spokeAngleLabelRadius * Math.cos(halfAngleRad);
      const spokeAngleLabelY = -spokeAngleLabelRadius * Math.sin(halfAngleRad);
      
      document.getElementById('spoke-angle-value').setAttribute('x', spokeAngleLabelX);
      document.getElementById('spoke-angle-value').setAttribute('y', spokeAngleLabelY);
      document.getElementById('spoke-angle-value').textContent = `${spokeAngleClock.toFixed(0)}°`;
      document.getElementById('spoke-angle-value').style.visibility = 'visible';
    } else {
      document.getElementById('spoke-angle-value').style.visibility = 'hidden';
    }
    
    // Update all labels
    document.getElementById('angle-label').textContent = `Angle Blue-Red: ${arrowAngleClock.toFixed(1)}°`;
    document.getElementById('turning-label').textContent = `Rotation Angle: ${rot.toFixed(1)}°`;
    document.getElementById('spoke-angle-label').textContent = `Spoke Angle: ${spokeAngleClock.toFixed(1)}°`;
    document.getElementById('red-angle-label').textContent = `Red Arrow: ${iAngle.toFixed(1)}°`;
    
    // Check if lines are parallel (exactly 0 or 180 degrees)
    if (arrowAngleClock === 0 || arrowAngleClock === 180) {
      document.getElementById('parallel-message').textContent = "Parallel";
    } else {
      document.getElementById('parallel-message').textContent = "";
    }
  } catch(err) {
    console.log("Error updating visualization:", err);
  }
}
